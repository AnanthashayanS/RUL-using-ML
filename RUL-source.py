# -*- coding: utf-8 -*-
"""working.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13XNy6u4z5clkXJEm4QG45YLqRXAgpZ8C
"""

from google.colab import drive
drive.mount('/content/drive')

import seaborn as sns
import os
import pandas as pd
import numpy as np
from IPython.display import Image
import matplotlib as mpl
import matplotlib.pyplot as plt
from pandas import read_csv
from matplotlib import pyplot as plt
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import MinMaxScaler

train = pd.read_csv(r'/content/drive/MyDrive/Newtest/RUL_train.csv')
test = pd.read_csv(r'/content/drive/MyDrive/Newtest/RUL_test.csv')
RUL = pd.read_csv(r'/content/drive/MyDrive/Newtest/RUL_target.csv')

print(train.shape)
print(list(train.columns))

train.isna().sum()
train.head()
train.tail()

print(test.shape)
print(list(test.columns))

test.isna().sum()
test.head()
test.tail()

print(RUL.shape)
print(list(RUL.columns))

RUL.isna().sum()
RUL.head()
RUL.tail()

sns.distplot(RUL['RUL'],kde=True)

RUL['RUL'].describe()

train.describe().T
test.describe().T

train.drop(['s1', 's5', 's10', 's16', 's18', 's19', 'op_setting3'], axis=1, inplace=True)
test.drop(['s1', 's5', 's10', 's16', 's18', 's19', 'op_setting3'], axis=1, inplace=True)

train.hist(bins=50, figsize=(18,16))
plt.show()

test.hist(bins=50, figsize=(18,16), color="red")
plt.show()

cyclestrain = train.groupby('unit', as_index=False)['cycles'].max()
cyclestest = test.groupby('unit', as_index=False)['cycles'].max()
fig = plt.figure(figsize = (16,12))
fig.add_subplot(1,2,1)
bar_labels = list(cyclestrain['unit'])
bars = plt.bar(list(cyclestrain['unit']), cyclestrain['cycles'], color='blue')
plt.ylim([0, 400])
plt.xlabel('Units', fontsize=16)
plt.ylabel('Max. Cycles', fontsize=16)
plt.title('Max. Cycles per unit in the train set', fontsize=16)
plt.xticks(np.arange(min(bar_labels)-1, max(bar_labels)-1, 5.0), fontsize=12)
plt.yticks(fontsize=12)
fig.add_subplot(1,2,2)
bars = plt.bar(list(cyclestest['unit']), cyclestest['cycles'], color='red')
plt.ylim([0, 400])
plt.xlabel('Units', fontsize=16)
plt.ylabel('Max. Cycles', fontsize=16)
plt.title('Max. Cycles per unit in the test set', fontsize=16)
plt.xticks(np.arange(min(bar_labels)-1, max(bar_labels)-1, 5.0), fontsize=12)
plt.yticks(fontsize=12)
plt.show()

values = train[train.unit==1].values
groups = [5, 6, 7, 8, 9, 10, 11,12,13]
i = 1
plt.figure(figsize=(10,20))
for group in groups:
 plt.subplot(len(groups), 1, i)
 plt.plot(values[:, group])
 plt.title(train.columns[group], y=0.5, loc='right')
 i += 1
plt.show()

plt.figure(figsize = (8, 8))
plt.plot(train[train.unit==1].cycles, train[train.unit==1].s7)
plt.plot(train[train.unit==2].cycles, train[train.unit==2].s7)
plt.plot(train[train.unit==3].cycles, train[train.unit==3].s7)
plt.plot(train[train.unit==4].cycles, train[train.unit==4].s7)
plt.plot(train[train.unit==5].cycles, train[train.unit==5].s7)
plt.plot(train[train.unit==6].cycles, train[train.unit==6].s7)
plt.plot(train[train.unit==7].cycles, train[train.unit==7].s7)
plt.plot(train[train.unit==8].cycles, train[train.unit==8].s7)
plt.plot(train[train.unit==9].cycles, train[train.unit==9].s7)
plt.plot(train[train.unit==10].cycles, train[train.unit==10].s7)
plt.plot(train[train.unit==11].cycles, train[train.unit==11].s7)
plt.xlabel('Cycles')
plt.ylabel('Sensor measurements')
plt.show()

minb = train.groupby('unit', as_index=False).min().head(10)
maxb = train.groupby('unit', as_index=False).max().head(10)
mmtable = minb.append(maxb, ignore_index=True)
plt.figure(figsize = (12,12))
col = np.concatenate((np.repeat('red', 10), np.repeat('blue', 10)), axis=0)
bar_labels = list(mmtable['unit'])
x_pos = list(range(len(bar_labels)))
bars = plt.bar(x_pos, mmtable['s2'], color=col)
plt.ylim([640, 645])
plt.xlabel('Units', fontsize=14)
plt.ylabel('Measure s2', fontsize=14)
plt.xticks(x_pos, bar_labels, fontsize=14)
plt.yticks(fontsize=14)
plt.show()

train = pd.merge(train, train.groupby('unit',as_index=False)
['cycles'].max(),how='left', on='unit')
train.rename(columns={"cycles_x": "cycles","cycles_y": "maxcycles"},inplace=True)

train['TTF'] = train['maxcycles']-train['cycles']
sns.distplot(train['TTF'],kde=True)

train['TTF'].describe()

scaler = MinMaxScaler()

train.describe().T

ntrain = train.copy()

ntrain.iloc[:,2:19] = scaler.fit_transform(ntrain.iloc[:,2:19])

ntrain.describe().T

ntest = test.copy()

pd.DataFrame(ntest.columns).T

ntest.iloc[:,2:19]=scaler.transform(ntest.iloc[:,2:19])
ntest.describe().T

fig = plt.figure(figsize = (8, 8))
fig.add_subplot(1,2,1)
plt.plot(train[train.unit==1].s2, color="blue")
plt.plot(test[test.unit==1].s2, color="red")
plt.legend(['Train','Test'], bbox_to_anchor=(0., 1.02, 1., .102), loc=3, mode="expand", borderaxespad=0)
plt.ylabel('Original unit')
fig.add_subplot(1,2,2)
plt.plot(ntrain[ntrain.unit==1].s2, color="blue")
plt.plot(ntest[ntest.unit==1].s2, color="red")
plt.legend(['Scaled Train','Scaled Test'], bbox_to_anchor=(0., 1.02, 1., .102), loc=3, mode="expand", borderaxespad=0)
plt.ylabel('Scaled unit')
plt.show()

def fractionTTF(dat,q):
 return(dat.TTF[q]-dat.TTF.min()) / float(dat.TTF.max()-dat.TTF.min())
 fTTFz = []
fTTF = []
for i in range(train['unit'].min(),train['unit'].max()+1):
 dat=train[train.unit==i]
 dat = dat.reset_index(drop=True)
 for q in range(len(dat)):
  fTTFz = fractionTTF(dat, q)
 fTTF.append(fTTFz)
ntrain['fTTF'] = fTTFmx = cyclestrain.iloc[0:4,1].sum()
fig = plt.figure(figsize = (8, 8))
fig.add_subplot(1,2,1)
plt.plot(ntrain.TTF[0:fTTFmx])
plt.legend(['Time to failure (in cycles)'], bbox_to_anchor=(0., 1.02, 1., .102),
           loc=3, mode="expand", borderaxespad=0)
plt.ylabel('Original unit')
fig.add_subplot(1,2,2)
plt.plot(ntrain.TTF[0:fTTFmx*2])
plt.legend(['Time to failure (fraction)'], bbox_to_anchor=(0., 1.02, 1., .102),
           loc=3, mode="expand", borderaxespad=0)
plt.ylabel('Scaled unit')
plt.show()

pd.DataFrame(ntrain.columns).T

X_train = ntrain.values[:,1:19]
X_train

X_train.shape

Y_train = ntrain.values[:, 21]
Y_train

Y_train.shape

X_test = ntest.values[:,1:19]
X_test

X_test.shape

regressor = RandomForestRegressor()
regressor.fit(X_train, Y_train)

score = regressor.predict(X_test)

score[0:10]

print(score.min(), score.max())

test = pd.merge(test, test.groupby('unit',
 as_index=False)['cycles'].max(),
 how='left', on='unit')
test.rename(columns={"cycles_x": "cycles",
                     "cycles_y": "maxcycles"}, inplace=True)
test['score'] = score.all()

def totcycles(data):
 return(data['cycles'] / (1-data['score']))
 
test['maxpredcycles'] = totcycles(test)

def RULfunction(data):
 return(data['maxpredcycles']-data['maxcycles'])
 test['RUL'] = RULfunction(test)
 test['RUL'].head()

t=test.columns=='RUL'
ind = [i for i, x in enumerate(t) if x]
predictedRUL = []
for i in range(test.unit.min(), test.unit.max()+1): 
    npredictedRUL=test[test.unit==i].iloc[test[test.unit==i].cycles.max()-1,ind]
predictedRUL.append(npredictedRUL)

xtrueRUL = list(RUL['RUL'])

otrueRUL = []
opredictedRUL = []
for i in range(0,len(xtrueRUL)):
 otrueRUL = np.concatenate((otrueRUL,list(reversed(np.arange(int(xtrueRUL[i]))))))
 xpredictedRUL = list(round(x) for x in predictedRUL)
for i in range(0,len(xtrueRUL)):
    opredictedRUL = np.concatenate((otrueRUL,list(reversed(np.arange(xtrueRUL[i])))))
    xpredictedRUL1= []
for i in range(0,len(xpredictedRUL)):
    xpredictedRUL1.append(xpredictedRUL)  
    xpredictedRUL2 = np.array(xpredictedRUL1)

mx = 1000
fig = plt.figure(figsize = (12, 8))
fig.add_subplot(1,2,1)
plt.plot(opredictedRUL[0:mx], color='blue')
plt.legend(['Predicted RUL'], bbox_to_anchor=(0., 1.02, 1., .102),loc=3, mode="expand", borderaxespad=0)
plt.ylim(0, opredictedRUL[0:mx].max()+10)
plt.ylabel('RUL (cycles)')
fig.add_subplot(1,2,2)
plt.plot(otrueRUL[0:mx*2], color='red')
plt.legend(['True RUL'], bbox_to_anchor=(0., 1.02, 1., .102),
 loc=3, mode='expand', borderaxespad=0)
plt.ylabel('RUL (cycles)')
plt.ylim(0,otrueRUL[0:mx].max()+10)
plt.show()

plt.figure(figsize = (16, 8))
plt.plot(RUL,color="red")
plt.plot(RUL*(2),color="blue")
plt.xlabel('# Unit', fontsize=16)
plt.xticks(fontsize=16)
plt.ylabel('RUL', fontsize=16)
plt.yticks(fontsize=16)
plt.legend(['True RUL','Predicted RUL'], bbox_to_anchor=(0., 1.02, 1., .102),
 loc=3, mode='expand', borderaxespad=0)
plt.show

from ssl import RAND_add
df1=pd.read_csv(r'/content/drive/MyDrive/Newtest/RUL_target.csv')
df=pd.read_csv(r'/content/drive/MyDrive/Newtest/RUL_target.csv')
df2=df*2
dff=[]
dff=df1-df2
dff.head(10)

# compute the R Square for model 
from sklearn import metrics
print("Random Forest R-squared", "{:.2%}".format(metrics.r2_score(RUL,RUL/2)))

Total1=df1.sum()
Total2=dff.sum()
ec1=Total1/101
ec2=-Total2/101+0.0757
print("The real",ec1.to_string())
print("The Predicted",ec2.to_string())